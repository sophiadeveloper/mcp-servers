import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import { chromium } from "playwright";
import dotenv from "dotenv";

// Redirect console.log to console.error to prevent libraries from breaking the JSON-RPC stdout stream
console.log = console.error;
dotenv.config();

const server = new Server(
  {
    name: "playwright-node",
    version: "1.0.0",
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// --- Browser State ---
let browser = null;
let context = null;
let page = null;

/**
 * Initializes the Playwright browser and context lazily.
 */
async function ensureBrowser() {
  if (!browser) {
    console.error("Launching Chromium browser...");
    browser = await chromium.launch({
      headless: true, // Run in headless mode
      args: [
        '--disable-blink-features=AutomationControlled',
        '--disable-notifications',
        '--disable-geolocation'
      ]
    });
    context = await browser.newContext({
      // Set any default context options here, e.g. viewport size, user agent
    });
    page = await context.newPage();
    console.error("Browser and page initialized successfully.");
  }
  return { browser, context, page };
}

// --- Tool Handlers ---
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: "browser_navigate",
        description: "Navigates to a specific URL and waits for DOM content loaded.",
        inputSchema: {
          type: "object",
          properties: {
            url: { type: "string", description: "The URL to navigate to" },
          },
          required: ["url"],
        },
      },
      {
        name: "browser_click",
        description: "Clicks on an element matching the given selector.",
        inputSchema: {
          type: "object",
          properties: {
            selector: { type: "string", description: "Playwright/CSS selector" },
          },
          required: ["selector"],
        },
      },
      {
        name: "browser_fill",
        description: "Fills a form element matching the given selector with text.",
        inputSchema: {
          type: "object",
          properties: {
            selector: { type: "string", description: "Playwright/CSS selector" },
            value: { type: "string", description: "Text to fill" },
          },
          required: ["selector", "value"],
        },
      },
      {
        name: "browser_get_dom",
        description: "Returns a minimized accessibility-focused version of the DOM (ignoring scripts, styles, etc.).",
        inputSchema: {
          type: "object",
          properties: {},
        },
      },
      {
        name: "browser_screenshot",
        description: "Captures a Base64-encoded screenshot of the current viewport.",
        inputSchema: {
          type: "object",
          properties: {},
        },
      },
      {
        name: "browser_evaluate_js",
        description: "Evaluates JavaScript in the current page context and returns the result.",
        inputSchema: {
          type: "object",
          properties: {
            code: { type: "string", description: "JavaScript code to evaluate" },
          },
          required: ["code"],
        },
      },
      {
        name: "browser_annotate",
        description: "Highlights all interactive elements on the page with a number and returns a screenshot.",
        inputSchema: {
          type: "object",
          properties: {},
        },
      },
      {
        name: "browser_click_by_id",
        description: "Clicks on an element using the ID generated by browser_annotate.",
        inputSchema: {
          type: "object",
          properties: {
            id: { type: "number", description: "The ID number from the annotation screenshot" },
          },
          required: ["id"],
        },
      }
    ]
  };
});

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  // We will ensure the browser runs before any tool is executed (except maybe safe ones, but it's simpler this way)
  await ensureBrowser();

  const { name, arguments: args } = request.params;

  try {
    switch (name) {
      case "browser_navigate": {
        const url = String(args.url);

        // Allow URLs check
        const allowedUrlsStr = process.env.ALLOWED_URLS !== undefined ? process.env.ALLOWED_URLS : "localhost,127.0.0.1";
        if (allowedUrlsStr && allowedUrlsStr !== "*") {
          const allowedUrls = allowedUrlsStr.split(",").map(s => s.trim());
          try {
            const targetUrlObj = new URL(url);
            const isAllowed = allowedUrls.some(allowed => targetUrlObj.hostname === allowed || targetUrlObj.hostname.endsWith(`.${allowed}`));
            if (!isAllowed) {
              throw new Error(`Navigazione non consentita: host ${targetUrlObj.hostname} non in ALLOWED_URLS (${allowedUrls.join(", ")})`);
            }
          } catch (e) {
            // URL parsing failed or denied
            throw new Error(`URL invalido o non consentito: ${e.message}`);
          }
        }

        await page.goto(url, { waitUntil: "domcontentloaded", timeout: 15000 });
        const title = await page.title();
        const currentUrl = page.url();
        return {
          content: [{ type: "text", text: `Navigazione completata. URL: ${currentUrl}, Titolo: ${title}` }],
        };
      }

      case "browser_click": {
        const selector = String(args.selector);
        await page.click(selector, { timeout: 10000 });
        return {
          content: [{ type: "text", text: `Click su selettore '${selector}' eseguito con successo.` }],
        };
      }

      case "browser_fill": {
        const selector = String(args.selector);
        const value = String(args.value);
        await page.fill(selector, value, { timeout: 10000 });
        return {
          content: [{ type: "text", text: `Testo inserito nel selettore '${selector}' con successo.` }],
        };
      }

      case "browser_get_dom": {
        // Extracts a compact DOM structure
        const compactDOM = await page.evaluate(() => {
          function getCleanOutline(node) {
            // Skip invisible or irrelevant elements
            if (node.nodeType !== Node.ELEMENT_NODE && node.nodeType !== Node.TEXT_NODE) return null;
            if (node.nodeType === Node.TEXT_NODE) {
              const text = node.textContent.trim();
              return text ? text : null;
            }

            const t = node.tagName.toLowerCase();
            if (['script', 'style', 'svg', 'noscript', 'meta', 'link', 'iframe'].includes(t)) return null;

            const children = [];
            for (let child of node.childNodes) {
              const c = getCleanOutline(child);
              if (c) children.push(c);
            }

            // Important UI elements to keep
            const isInteractive = ['a', 'button', 'input', 'select', 'textarea', 'label'].includes(t);
            const role = node.getAttribute('role');
            const hasInteractiveRole = role && ['button', 'link', 'checkbox', 'menuitem'].includes(role);

            // If it's just a structural element with no children, ignore it
            if (!isInteractive && !hasInteractiveRole && children.length === 0) return null;

            // Create compact representation
            let str = `<${t}`;
            if (node.id) str += ` id="${node.id}"`;
            if (isInteractive || hasInteractiveRole) {
              // Basic identifiable attributes for targeting
              Array.from(node.attributes).forEach(attr => {
                if (['name', 'type', 'placeholder', 'aria-label', 'role'].includes(attr.name)) {
                  str += ` ${attr.name}="${attr.value}"`;
                }
              });
            }
            str += '>';

            if (children.length === 1 && typeof children[0] === 'string') {
              str += children[0];
            } else if (children.length > 0) {
              str += '\n  ' + children.map(c => typeof c === 'string' ? c : c).join('\n').replace(/\n/g, '\n  ') + '\n';
            }
            return str + `</${t}>`;
          }
          return getCleanOutline(document.body);
        });
        return {
          content: [{ type: "text", text: compactDOM || "Il DOM Ã¨ vuoto o non estraibile." }],
        };
      }

      case "browser_screenshot": {
        const buffer = await page.screenshot({ encoding: "base64", fullPage: false });
        return {
          content: [{
            type: "image",
            data: buffer,
            mimeType: "image/png"
          }],
        };
      }

      case "browser_evaluate_js": {
        const code = String(args.code);
        const result = await page.evaluate(code);
        const resultStr = typeof result === "object" ? JSON.stringify(result, null, 2) : String(result);
        return {
          content: [{ type: "text", text: `Execution result:\n${resultStr}` }],
        };
      }

      case "browser_annotate": {
        await page.evaluate(() => {
          let elements = document.querySelectorAll('a, button, input, textarea, select, [role="button"], [role="link"], [role="checkbox"], [role="menuitem"]');
          window.__elementMap = {};
          let counter = 1;

          // Remove old annotations if any
          document.querySelectorAll('.playwright-annotation').forEach(e => e.remove());

          elements.forEach(el => {
            const rect = el.getBoundingClientRect();
            // Check if visible
            const isVisible = rect.width > 0 && rect.height > 0 && window.getComputedStyle(el).visibility !== 'hidden';
            if (isVisible) {
              window.__elementMap[counter] = el;
              let label = document.createElement('div');
              label.textContent = counter;
              label.className = 'playwright-annotation';
              label.style.position = 'absolute';
              label.style.top = `${rect.top + window.scrollY}px`;
              label.style.left = `${rect.left + window.scrollX}px`;
              label.style.background = 'red';
              label.style.color = 'white';
              label.style.padding = '2px 4px';
              label.style.fontSize = '12px';
              label.style.fontWeight = 'bold';
              label.style.zIndex = '999999';
              label.style.pointerEvents = 'none';
              label.style.borderRadius = '3px';
              label.style.boxShadow = '0 0 2px black';
              document.body.appendChild(label);
              counter++;
            }
          });
        });

        // Wait a tiny bit for rendering
        await new Promise(resolve => setTimeout(resolve, 100));
        const buffer = await page.screenshot({ encoding: "base64", fullPage: true });

        return {
          content: [{
            type: "image",
            data: buffer,
            mimeType: "image/png"
          }, {
            type: "text",
            text: "Etichette iniettate. Usa l'ID visibile nell'immagine con browser_click_by_id."
          }],
        };
      }

      case "browser_click_by_id": {
        const id = Number(args.id);
        const result = await page.evaluate((selectorId) => {
          if (window.__elementMap && window.__elementMap[selectorId]) {
            // Rimuoviamo prima le annotazioni che potrebbero bloccare il click se pointerEvents:none non funziona altrove o per pulizia
            document.querySelectorAll('.playwright-annotation').forEach(e => e.remove());
            window.__elementMap[selectorId].click();
            return true;
          }
          return false;
        }, id);

        if (result) {
          return {
            content: [{ type: "text", text: `Elemento ${id} cliccato con successo.` }],
          };
        } else {
          throw new Error(`Elemento con ID ${id} non trovato. Esegui prima browser_annotate.`);
        }
      }

      default:
        return {
          content: [{ type: "text", text: `Tool ${name} non implementato ancora.` }],
          isError: true,
        };
    }
  } catch (error) {
    return {
      content: [{ type: "text", text: `Errore durante l'esecuzione di ${name}: ${error.message}` }],
      isError: true,
    };
  }
});

// --- Transport & Shutdown ---
const transport = new StdioServerTransport();
await server.connect(transport);
console.error("Playwright MCP Server running on stdio");

const cleanup = async () => {
  console.error("Shutting down server, closing browser...");
  if (browser) {
    await browser.close().catch(console.error);
    browser = null;
  }
  process.exit(0);
};

process.on("SIGINT", cleanup);
process.on("SIGTERM", cleanup);
process.on("exit", cleanup);

// Also handle stdio close
transport.onclose = cleanup;
